<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Andrés Millán Muñoz" />
  <meta name="keywords" content="TFG, Raytracing, Ray tracing, Monte
Carlo, DGIIM" />
  <title>Raytracing (WIP name)</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/bamboo.css/dist/light.min.css">
  <link rel="stylesheet" href="./headers/style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        chtml: {
            scale: 1.1
        },
        svg: {
            scale: 1.1
        }
    };
  </script>
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Raytracing (WIP name)</h1>
<p class="author">Andrés Millán Muñoz</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Tabla de contenidos</h2>
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#dedicatoria">Dedicatoria</a></li>
<li><a href="#introducción">Introducción</a>
<ul>
<li><a href="#qué-es-ray-tracing">¿Qué es ray tracing?</a></li>
<li><a href="#vale-y-qué-vamos-a-hacer-entonces">Vale, ¿y qué vamos a
hacer entonces?</a></li>
</ul></li>
<li><a href="#notación">Notación</a></li>
<li><a href="#los-fundamentos">Los fundamentos</a>
<ul>
<li><a href="#eligiendo-direcciones">Eligiendo direcciones</a></li>
<li><a href="#intersecciones-rayo---objeto">Intersecciones rayo -
objeto</a>
<ul>
<li><a href="#superficies-implícitas">Superficies implícitas</a></li>
<li><a href="#superficies-paramétricas">Superficies
paramétricas</a></li>
<li><a href="#intersecciones-con-esferas">Intersecciones con
esferas</a></li>
<li><a href="#intersecciones-con-triángulos">Intersecciones con
triángulos</a></li>
</ul></li>
</ul></li>
<li><a href="#integración-de-monte-carlo">Integración de Monte Carlo</a>
<ul>
<li><a href="#repaso-de-probabilidad">Repaso de probabilidad</a>
<ul>
<li><a href="#variables-aleatorias-discretas">Variables aleatorias
discretas</a></li>
<li><a href="#variables-aleatorias-continuas">Variables aleatorias
continuas</a></li>
</ul></li>
</ul></li>
<li><a href="#metodología-o-cómo-se-hizo-este-trabajo">Metodología; o
cómo se hizo este trabajo</a>
<ul>
<li><a href="#github">Github</a>
<ul>
<li><a href="#github-actions">Github Actions</a></li>
<li><a href="#github-projects">Github Projects</a></li>
</ul></li>
</ul></li>
<li><a href="#anexo-cheatsheet">Anexo: Cheatsheet</a></li>
</ul>
</nav>
<h1 id="abstract">Abstract</h1>
<p>Se procederá a analizar los algoritmos modernos de visualización 3D
realista usando métodos de Monte-Carlo, y su implementación en hardware
gráfico moderno (GPUs) específicamente diseñadas para aceleración de
Ray-Tracing. Se diseñará e implementará un sistema software de síntesis
de imágenes realistas por path tracing y muestreo directo de fuentes de
luz, que haga uso del hardware gráfico, y se analizará su eficiencia en
tiempo en relación a la calidad de las imágenes y en comparación con una
implementación exclusivamente sobre CPU.</p>
<p>Se realizará una revisión bibliográfica de los métodos de Montecarlo
que se aplican de manera habitual para la visualización de imagenes 3D.
Se examinarán los puntos fuertes y débiles de cada una de las técnicas,
con el objetivo de minimizar el error en la recosntrucción de la imagen
sin que esto suponga un alto coste computacional. Se investigarán las
soluciones propuestas para el futuro del área.</p>
<hr>
<p><em>Translation. It’ll be left as is until there’s a definitive
abstract</em></p>
<h1 id="dedicatoria">Dedicatoria</h1>
<p><em>Aquí es donde me pongo ñoño</em></p>
<p>¡Parece que has llegado un poco pronto! Si lo has hecho
voluntariamente, ¡muchas gracias! Este proyecto debería estar finalizado
en verano de 2022.</p>
<p>Mientras tanto, actualizaré poco a poco el contenido. Si quieres ir
comprobando los progresos, puedes visitar <a
href="github.com/Asmilex/Raytracing">Asmilex/Raytracing</a> en Github
para ver el estado del desarrollo.</p>
<h1 id="introducción">Introducción</h1>
<p>Ser capaces de capturar un momento.</p>
<p>Desde siempre, este ha sido uno de los sueños de la humanidad. La
capacidad de retener lo que ven nuestros ojos comenzó con simples
pinturas ruprestres. Con el tiempo, el arte evolucionó, así como la
capacidad de retratar nuestra percepción con mayor fidelidad.</p>
<p>A inicios del siglo XVIII, se caputaron las primeras imágenes con una
cámara gracias a Nicéphore Niépce. Sería una imagen primitiva, claro;
pero era funcional. Gracias a la compañía Kodak, la fotografía se
extendió al consumidor rápidamente sobre 1890. Más tarde llegaría la
fotografía digital, la cual simplificaría muchos de los problemas de las
cámaras tradicionales.</p>
<p>Hablando de digital. Los ordenadores personales modernos nacieron
unos años más tarde. Los usuarios eran capaces de mostrar imágenes en
pantalla, que cambiaban bajo demanda. Y, entonces, nos hicimos una
pregunta…</p>
<p>¿Podríamos <strong>simular la vida real</strong> para mostrarla en
pantalla?</p>
<p>Como era de esperar, esto es complicado de lograr. Para conseguirlo,
hemos necesitado crear abstracciones de conceptos que nos resultan
naturales, como objetos, luces y seres vivos. <em>“Cosas”</em> que un
ordenador no entiende, y sin embargo, para nosotros
<em>funcionan</em>.</p>
<p>Así, nació la geometría, los puntos de luces, texturas, sombreados, y
otros elementos de un escenario digital. Pero, por muchas abstracciones
elegantes que tengamos, no nos basta. Necesitamos visualizarlas. Y como
podemos imaginarnos, esto es un proceso costoso.</p>
<p>La <strong>rasterización</strong> es el proceso mediante el cual
estos objetos tridimensionales se transforman en bidimensionales.
Proyectando acordemente el entorno a una cámara, conseguimos colorear un
pixel, de forma que represente lo que se ve en ese mundo.</p>
<blockquote>
<p>TODO insertar imagen rasterización. NOTE quizás debería extender un
poco más esta parte? Parece que se queda algo coja la explicación.</p>
</blockquote>
<p>Aunque esta técnica es bastante eficiente en términos de computación
y ha evolucionado mucho, rápidamente saturamos sus posibilidades.
Conceptos como <em>shadow maps</em>, <em>baked lightning</em>, o
<em>reflection cubemaps</em> intentan solventar lo que no es posible con
rasterización: preguntrarnos <em>qué es lo que se encuentra alrededor
nuestra</em>.</p>
<p>En parte, nos olvidamos de la intuitiva realidad, para centrarnos en
aquello computacionalmente viable.</p>
<p>Y, entonces, en 1960 el trazado de rayos con una simple idea
intuitiva .</p>
<h2 id="qué-es-ray-tracing">¿Qué es ray tracing?</h2>
<p>En resumidas cuentas, <em>ray tracing</em> (o trazado de rayos en
español), se basa en disparar fotones desde nuestras luces digitales y
hacerlos rebotar en la escena.</p>
<p>De esta forma, simulamos cómo se comporta la luz. Al impactar en un
objeto, sufre un cambio en su trayectoria. Este cambio origina nuevos
rayos, que vuelven a dispersarse por la escena. Estos nuevos rayos
dependerán de las propiedades del objeto con el que hayan impactado. Con
el tiempo necesario, lo que veremos desde nuestra cámara será una
representación fotorealista de lo que habita en ese universo.</p>
<p>Esta técnica, tan estúpidamente intuitiva, se ha hecho famosa por su
simpleza y su elegancia. <em>Pues claro</em> que la respuesta a
“<em>¿Cómo simulamos fielmente una imagen en un ordenador?</em>” es
“<em>Representando la luz de forma realista</em>”.</p>
<p>Aunque, quizás intuitiva no sea la palabra. Podemos llamarla
<em>natural</em>, eso sí. A fin de cuentas, fue a partir del siglo XVIII
cuando empezamos a entender que podíamos capturar la luz. Nuestros
antepasados tenían teorías, pero no podían explicar por qué
<em>veíamos</em> el mundo.</p>
<p>Ahora sí que sabemos cómo funciona. Entendiendo el por qué lo hace
nos permitirá programarlo. Y, resulta que funciona impresionantemente
bien.</p>
<p>Atrás se quedan los <em>hacks</em> necesarios para rasterización. Los
cubemaps no son esenciales para los reflejos, y no necesitamos cámaras
virtuales para calcular sombras. Ray tracing permite simular fácilmente
efectos como reflejos, refracción, desenfoque de movimiento, aberración
cromática… Incluso fenómenos físicos propios de las particulas y las
ondas.</p>
<blockquote>
<p>Espera. Si tan bueno es, ¿por qué no lo usamos en todos lados?</p>
</blockquote>
<p>Por desgracia, el elefante en la sala es el rendimiento. Como era de
esperar, disparar rayos a diestro y siniestro es costoso. <strong>Muy
costoso</strong>.</p>
<p>A diferencia del universo, nosotros no nos podemos permitir el lujo
de usar fotones de tamaño infinitesimal y dispersiones casi infinitas.
Nos pasaríamos una eternidad esperando. Y para ver una imagen en nuestra
pantalla necesitaremos estar vivos, claro.</p>
<p>Debemos evitar la fuerza bruta. Dado que la idea es tan elegante, la
respuesta no está en el <em>“qué”</em>, sino en el <em>“cómo”</em>. Si
<strong>disparamos y dispersamos rayos con cabeza</strong> seremos
capaces de obtener lo que buscamos en un tiempo razonable.</p>
<p>Hace unos años, al hablar de tiempo razonable, nos referiríamos a
horas. Quizás días. Producir un <em>frame</em> podría suponer una
cantidad de tiempo impensable para un ordenador de consumidor. Hoy en
día también ocurre esto, claro está. Pero la tecnología evoluciona.</p>
<p>Podemos bajarlo a milisegundos.</p>
<p>Hemos entrado en la era del <strong>real time ray
tracing</strong>.</p>
<h2 id="vale-y-qué-vamos-a-hacer-entonces">Vale, ¿y qué vamos a hacer
entonces?</h2>
<blockquote>
<p>TODO hablar de los objetivos del trabajo.</p>
</blockquote>
<hr>
<p>Referencias que pasar después:</p>
<ol type="1">
<li>https://www.wikiwand.com/en/History_of_photography#/1816_to_1833:_Ni%C3%A9pce’s_earliest_fixed_images</li>
<li>https://www.wikiwand.com/es/Kodak#/Historia</li>
<li>https://www.wikiwand.com/en/Computer#/Digital_computers</li>
<li>https://www.wikiwand.com/en/Rendering_(computer_graphics)#/Chronology_of_important_published_ideas</li>
<li>Ray tracing gems I (p 16), gems II.</li>
<li>https://blogs.nvidia.com/blog/2018/03/19/whats-difference-between-ray-tracing-rasterization/</li>
<li>https://www.wikiwand.com/en/Ray_tracing_(graphics)</li>
<li>https://sciencebehindpixar.org/pipeline/rendering#:~:text=They%20said%20it%20takes%20at,to%20render%20that%20many%20frames.</li>
<li></li>
</ol>
<h1 id="notación">Notación</h1>
<p>Antes de comenzar, asentemos la notación que utilizaremos.</p>
<p>Para denotar a los <strong>puntos</strong>, usaremos letras
mayúsculas como <span class="math inline">\(P\)</span> o <span
class="math inline">\(Q\)</span>. Los <strong>escalares</strong> vendrán
dados por letras minúsculas, como <span class="math inline">\(a\)</span>
o <span class="math inline">\(b\)</span>; mientras que los
<strong>vectores</strong> irán en letra minúscula negrita (p.e.: <span
class="math inline">\(\mathbf{v}\)</span> o <span
class="math inline">\(\mathbf{w}\)</span>). Además, serán vectores
columnas. Aquellos normalizados los representaremos con un gorrito:
<span class="math inline">\(\hat{\mathbf{v}} =
\frac{\mathbf{v}}{\Vert\mathbf{v}\Vert}\)</span>. Las
<strong>matrices</strong>, por otra parte, vendrán dadas por letra
mayúscula en negrita, como <span
class="math inline">\(\mathbf{M}\)</span>. También son columna.</p>
<p>El producto escalar vendrá dado por <span
class="math inline">\(\mathbf{v} \cdot \mathbf{w}\)</span>, y el
vectorial por <span class="math inline">\(\mathbf{v} \times
\mathbf{w}\)</span>. Cuando escribamos <span
class="math inline">\(\mathbf{v}^2\)</span>, lo entenderemos como <span
class="math inline">\(\mathbf{v} \cdot \mathbf{v}\)</span></p>
<p>La notación usada para las <strong>variables aleatorias</strong> será
la habitual: mayúsculas como <span class="math inline">\(X\)</span>. Su
valor esperado vendrá dado por <span
class="math inline">\(E\left[X\right]\)</span> y la varianza por <span
class="math inline">\(V\left[X\right]\)</span>.</p>
<blockquote>
<p>TODO: notación para las funciones de densidad y distribución. TODO:
acceso a componentes de un vector/matriz?</p>
</blockquote>
<h1 id="los-fundamentos">Los fundamentos</h1>
<p>Empecemos por definir lo que es un rayo.</p>
<p>Un rayo es una función <span class="math inline">\(P(t) = O +
tD\)</span>, donde <span class="math inline">\(O\)</span> es el origin,
<span class="math inline">\(D\)</span> la dirección, y <span
class="math inline">\(t \in \mathbb{R}\)</span>. Podemos considerarlo
una interpolación entre dos puntos en el espacio, donde <span
class="math inline">\(t\)</span> controla la posición en la que nos
encontramos.</p>
<p>Por ejemplo, si <span class="math inline">\(t = 0\)</span>,
obtendremos el origen. Si <span class="math inline">\(t = 1\)</span>,
obtendremos el punto correspondiente a la dirección. Usando valores
negativos vamos <em>hacia atrás</em>.</p>
<figure>
<img src="./img/rayo.png" />
</figure>
<p>Dado que estos puntos estarán generalmente en <span
class="math inline">\(\mathbb{R}^3\)</span>, podemos escribirlo como</p>
<p><span class="math display">\[
P(t) = (O_x, O_y, O_z) + t (D_x, D_y, D_z)
\]</span></p>
<p>Estos rayos los <em>dispararemos</em> a través de una cámara virtual,
que estará enfocando a la escena. De esta forma, los haremos rebotar con
los objetos que se encuentren en el camino del rayo. A este proceso lo
llamaremos <strong>ray casting</strong>.</p>
<blockquote>
<p>TODO foto de cámara - pixel - rayo - objeto.</p>
</blockquote>
<p>Generalmente, nos quedaremos con el primer objeto que nos encontremos
en su camino. Aunque, a veces, nos interesará saber todos con los que se
encuentre.</p>
<p>Cuando un rayo impacta con un objeto, adquirirá parte de las
propiedades lumínicas del punto de impacto. Por ejemplo, cuánta luz
proporciona la lámpara que tiene encima la esfera de la figura
anterior.</p>
<p>Una vez recojamos la información que nos interese, aplicaremos otro
raycast desde el nuevo punto de impacto, escogiendo una nueva dirección
determinada. Esta dirección dependerá del tipo de material del objeto.
Y, de hecho, algunos serán capaces de invocar varios rayos.</p>
<p>Por ejemplo, los espejos reflejan la luz casi de forma perfecta;
mientras que otros elementos como el agua o el cristal reflejan
<em>y</em> refractan luz, así que necesitaremos generar dos nuevos
raycast.</p>
<p>Usando suficientes rayos obtendremos la imagen de la escena. A este
proceso de <strong>ray casting recursivo</strong> es lo que se conoce
como ray tracing.</p>
<p>Como este proceso puede continuar indefinidamente, tendremos que
controlar la profundidad de la recursión. A mayor profundidad, mayor
calidad de imagen; pero también, mayor tiempo de ejecución.</p>
<h2 id="eligiendo-direcciones">Eligiendo direcciones</h2>
<p>Una de las partes más importantes de ray tracing, y a la que quizás
dedicaremos más tiempo, es a la elección de la dirección.</p>
<p>Hay varios factores que entran en juego a la hora de decidir qué
hacemos cuando impactamos con un nuevo objeto:</p>
<ol type="1">
<li><strong>¿Cómo es la superficie del material?</strong> A mayor
rugosidad, mayor aleatoriedad en la dirección. Por ejemplo, no es lo
mismo el asfalto de una carretera que una lámina de aluminio
impecable.</li>
<li><strong>¿Cómo de fiel es nuestra geometría?</strong></li>
<li><strong>¿Dónde se encuentran las luces en la escena?</strong>
Dependiendo de la posición, nos interesará muestrear la luz con mayor
influencia.</li>
</ol>
<p>Estas cuestiones las exploraremos a fondo en las siguientes
secciones.</p>
<h2 id="intersecciones-rayo---objeto">Intersecciones rayo - objeto</h2>
<p>Como dijimos al principio del capítulo, representaremos un rayo
como</p>
<p><span class="math display">\[
\begin{aligned}
P(t) &amp; = (O_x, O_y, O_z) + t (D_x, D_y, D_z) = \\
&amp; = (O_x + t D_x, O_y + t D_y, O_y + t D_z)
\end{aligned}
\]</span></p>
<p>Por ejemplo, tomando <span class="math inline">\(O = (1, 3, 2), D =
(1, 2, 1)\)</span>:</p>
<ul>
<li>Para <span class="math inline">\(t = 0\)</span>, <span
class="math inline">\(P(t) = (1, 3, 2)\)</span>.</li>
<li>Para <span class="math inline">\(t = 1\)</span>, <span
class="math inline">\(P(t) = (1, 3, 2) + (1, 2, 1) = (2, 5,
3)\)</span>.</li>
</ul>
<p>Nos resultará especialmente útil limitar los valores que puede tomar
<span class="math inline">\(t\)</span>. Restringiremos los posibles
puntos del dominio de forma que <span class="math inline">\(t \in
[t_{min}, t_{max})\)</span>, con <span class="math inline">\(t_{min}
&lt; t_{max}\)</span>. En general, nos interesará separarnos de las
superficies un pequeño pero no despreciable <span
class="math inline">\(\varepsilon\)</span> para evitar errores de
redondeo.</p>
<blockquote>
<p>TODO dibujo origen - epsilon == tmin -&gt; rayo -&gt; t_max =
1-epsilon</p>
</blockquote>
<p>Una de las principales cuestiones que debemos hacernos es saber
cuándo un rayo impacta con una superficie. Lo definiremos
analíticamente.</p>
<h3 id="superficies-implícitas">Superficies implícitas</h3>
<p>Generalmente, cuando hablemos de superficies, nos referiremos <a
href="https://www.wikiwand.com/en/Differential_geometry_of_surfaces">superficies
diferenciables</a>, pues nos interesará conocer el vector normal en cada
punto.</p>
<p>Una superficie implícita es una superficie en un espacio euclidiano
definida como</p>
<p><span class="math display">\[
F(x, y, z) = 0
\]</span></p>
<p>Esta ecuación implícita define una serie de puntos del espacio <span
class="math inline">\(\mathbb{R}^3\)</span> que se encuentran en la
superficie.</p>
<p>Por ejemplo, la esfera se define como <span class="math inline">\(x^2
+ y^2 + z^2 - 1 = 0\)</span>.</p>
<p>Consideremos una superficie <span class="math inline">\(S\)</span> y
un punto regular de ella <span class="math inline">\(P\)</span>; es
decir, un punto tal que el gradiente de <span
class="math inline">\(F\)</span> en <span
class="math inline">\(P\)</span> no es 0. Se define el vector normal
<span class="math inline">\(\mathbf{n}\)</span> a la superficie en ese
punto como</p>
<p><span class="math display">\[
\mathbf{n} = \nabla F(P) = \left( \frac{\partial F(P)}{\partial x},
\frac{\partial F(P)}{\partial y}, \frac{\partial F(P)}{\partial z}\right
)
\]</span></p>
<blockquote>
<p>TODO: dibujo de la normal a una superficie.</p>
</blockquote>
<p>Dado un punto <span class="math inline">\(Q \in
\mathbb{R}^3\)</span>, queremos saber dónde interseca un rayo <span
class="math inline">\(P(t)\)</span>. Es decir, para qué <span
class="math inline">\(t\)</span> se cumple que <span
class="math inline">\(F(P(t)) = 0 \iff F(O + tD) = 0\)</span>.</p>
<p>Consideremos por ejemplo un plano, como en <span class="citation"
data-cites="ShirleyRRT">(<a href="#ref-ShirleyRRT"
role="doc-biblioref">Shirley and Morley 2003</a>)</span>. Para ello, nos
tomamos un punto <span class="math inline">\(Q_0\)</span> del plano y un
vector normal a la superficie <span
class="math inline">\(\mathbf{n}\)</span>.</p>
<p>La ecuación implícita del plano será</p>
<p><span class="math display">\[
F(Q) = (Q - Q_0) \cdot \mathbf{n} = 0
\]</span></p>
<p>Si pinchamos nuestro rayo en la ecuación,</p>
<p><span class="math display">\[
\begin{aligned}
F(P(t)) &amp; = (P(t) - Q_0) \cdot \mathbf{n} \\
        &amp; = (O + tD - Q_0) \cdot \mathbf{n} = 0 \\
\end{aligned}
\]</span></p>
<p>Resolviendo para <span class="math inline">\(t\)</span>, esto se da
si</p>
<p><span class="math display">\[
\begin{aligned}
O \cdot \mathbf{n} + tD \cdot \mathbf{n} - Q_0 \cdot \mathbf{n} &amp; =
0 &amp; \iff \\
tD \cdot \mathbf{n} &amp; = Q_0 \cdot \mathbf{n} - O \cdot \mathbf{n}
&amp; \iff \\
t &amp; = \frac{Q_0 \cdot \mathbf{n} - O \cdot \mathbf{n}}{D \cdot
\mathbf{n}}
\end{aligned}
\]</span></p>
<p>Es decir, hemos obtenido el único valor de <span
class="math inline">\(t\)</span> para el cual el rayo toca la
superficie.</p>
<p>Debemos tener en cuenta el caso para el cual <span
class="math inline">\(D \cdot \mathbf{n} = 0\)</span>. Esto solo se da
si la dirección y el vector normal a la superficie son paralelos.</p>
<blockquote>
<p>TODO: dibujo de dos rayos con un plano: uno corta a la superficie,
mientras que el otro es paralelo.</p>
</blockquote>
<h3 id="superficies-paramétricas">Superficies paramétricas</h3>
<p>Otra forma de definir una superficie en el espacio es mediante un
subconjunto <span class="math inline">\(D \subset \mathbb{R}^2\)</span>
y una serie de funciones, <span class="math inline">\(f, g, h: D
\rightarrow \mathbb{R}^3\)</span>, de forma que</p>
<p><span class="math display">\[
(x, y, z) = \left( f(u, v), g(u, v), h(u, v) \right) \\
\]</span></p>
<blockquote>
<p>En informática gráfica, hacemos algo similar cuando mapeamos una
textura a una superficie. Se conoce como UV mapping</p>
</blockquote>
<p>Demos un par de ejemplos de superficies paramétricas: - El grafo de
una función <span class="math inline">\(f: D \rightarrow
\mathbb{R}^3\)</span>, <span class="math display">\[
G(f) = \left\{(x, y, f(x, y)) \,\middle|\,  (x, y) \in D\right\}
\]</span> define una superficie diferenciable siempre que <span
class="math inline">\(f\)</span> también lo sea. - Usando coordenadas
esféricas <span class="math inline">\((r, \theta, \phi)\)</span>,
podemos parametrizar la esfera como <span class="math inline">\((x, y,
z) = (\cos\phi\sin\theta, \sin\phi\sin\theta, \cos\theta)\)</span></p>
<blockquote>
<p>TODO añadir imagen de coordenadas esféricas. U otro capítulo con
coordenadas.</p>
<p>NOTE: estoy usando (radial, polar, azimuthal). <span
class="math inline">\(\theta\)</span> corresponde con la apertura con
respecto a la vertical</p>
</blockquote>
<p>El vector normal <span class="math inline">\(\mathbf{n}\)</span> a la
superficie en un punto <span class="math inline">\((u, v)\)</span> del
dominio viene dado por</p>
<p><span class="math display">\[
\mathbf{n}(u, v) =
        \left( \frac{\partial f}{\partial u}, \frac{\partial g}{\partial
u}, \frac{\partial h}{\partial u} \right)
                \times
        \left( \frac{\partial f}{\partial v}, \frac{\partial g}{\partial
v}, \frac{\partial h}{\partial v} \right)
\]</span></p>
<p>Encontrar el punto de intersección de una superficie paramétrica con
un rayo es sencillo. Basta con encontrar aquellos puntos <span
class="math inline">\((u, v)\)</span> y <span
class="math inline">\(t\)</span> para los que</p>
<p><span class="math display">\[
\begin{aligned}
O_x + tD_x &amp; = f(u, v) \\
O_y + tD_y &amp; = g(u, v) \\
O_z + tD_z &amp; = h(u, v) \\
\end{aligned}
\]</span></p>
<p>Es posible que el rayo no impacte en ningún punto. En ese caso, el
sistema de ecuaciones no tendría solución. Otra posibilidad es que
intersequen en varios puntos.</p>
<h3 id="intersecciones-con-esferas">Intersecciones con esferas</h3>
<p>Estudiemos ahora cómo intersecan las esfera con nuestro rayo. Una
esfera de centro <span class="math inline">\(C\)</span> y radio <span
class="math inline">\(r\)</span> viene dada por aquellos puntos <span
class="math inline">\(P = (x, y, z)\)</span> que cumplen</p>
<p><span class="math display">\[
(P - C) \cdot (P - C) = r^2
\]</span></p>
<p>Podemos reescribir esta ecuación en términos de sus coordenadas para
obtener</p>
<p><span class="math display">\[
(x - C_x)^2 + (y - C_y)^2 + (z - C_z)^2 = r^2
\]</span></p>
<p>Veamos para qué valores de <span class="math inline">\(t\)</span> de
nuestro rayo se cumple esa ecuación:</p>
<p><span class="math display">\[
\begin{aligned}
(P(t) - C) \cdot (P(t) - C) &amp; = r^2 &amp; \iff \\
(O + tD - C) \cdot (O + tD - C) &amp; = r^2 &amp; \iff \\
\end{aligned}
\]</span></p>
<p>Aplicando las propiedades del producto escalar de la conmutatividad
(<span class="math inline">\(a \cdot b = b \cdot a\)</span>) y la
distributiva (<span class="math inline">\(a \cdot (b + c) = a \cdot b +
a \cdot c\)</span>), podemos escribir</p>
<p><span class="math display">\[
\begin{aligned}
((O - C) + tD) \cdot ((O - C) + tD) &amp; = r^2 &amp; \iff \\
(O - C)^2 + 2 \cdot (O - C) \cdot tD + (tD)^2 &amp; = r^2 &amp; \iff \\
D^2t^2 + 2 D \cdot (O - C)t + (O - C)^2 - r^2 &amp; = 0 &amp; \iff \\
\end{aligned}
\]</span></p>
<p>Así que tenemos una ecuación de segundo grado. Resolviéndola, nos
salen nuestros puntos de intersección:</p>
<p><span class="math display">\[
t = \frac{
    - D \cdot (O - C) \pm \sqrt{(D \cdot (O - C))^2 - 4 (D^2)((O - C)^2
- r^2)}
}{
    2 D^2
}
\]</span></p>
<p>Debemos distinguir tres casos, atiendiendo al valor que toma el
discriminante <span class="math inline">\(\Delta = \small{(D \cdot (O -
C))^2 - 4 (D^2)((O - C)^2 - r^2)}\)</span>:</p>
<ol type="1">
<li>Si <span class="math inline">\(\Delta &lt; 0\)</span>, <span
class="math inline">\(\sqrt{\Delta} \notin \mathbb{R}\)</span>, y el
rayo no impacta con la esfera</li>
<li>Si <span class="math inline">\(\Delta = 0\)</span>, el rayo impacta
en un punto, que toma el valor <span class="math inline">\(t = \frac{-D
\cdot (O - C)}{2 D \cdot D}\)</span>. Digamos que <em>pegaría</em> justo
en el borde.</li>
<li>Si <span class="math inline">\(\Delta &gt; 0\)</span>, existen dos
soluciones. En ese caso, el rayo atraviesa la esfera.</li>
</ol>
<blockquote>
<p>TODO dibujo explicativo de la intersección con una esfera.</p>
</blockquote>
<p>Para estos dos últimos, si consideramos <span
class="math inline">\(t_0\)</span> cualquier solución válida, el vector
normal resultante viene dado por</p>
<p><span class="math display">\[
\mathbf{n} = 2 (P(t_0) - C)
\]</span></p>
<p>o, normalizando,</p>
<p><span class="math display">\[
\hat{\mathbf{n}} = \frac{(P(t_0) - C)}{r}
\]</span></p>
<h3 id="intersecciones-con-triángulos">Intersecciones con
triángulos</h3>
<p>Este tipo de intersecciones serán las más útiles en nuestro path
tracer. Generalmente, nuestras geometrías estarán compuestas por mallas
de triángulos, así que conocer dónde impacta nuestro rayo será clave.
Empecemos por la base:</p>
<p>Un triángulo viene dado por tres puntos, <span
class="math inline">\(A, B\)</span>, y <span
class="math inline">\(C\)</span>; correspondientes a sus vértices. Para
evitar casos absurdos, supongamos que estos puntos son afinmente
independientes; es decir, que no están alineados.</p>
<h4 id="coordenadas-baricéntricas">Coordenadas baricéntricas</h4>
<p>Podemos describir los puntos contenidos en el plano que forman estos
vertices mediante <strong>coordenadas baricéntricas</strong>. Este
sistema de coordenadas expresa cada punto del plano como una combinación
convexa de los vértices. Es decir, que para cada punto <span
class="math inline">\(P\)</span> del triángulo existen <span
class="math inline">\(\alpha, \beta\)</span> y <span
class="math inline">\(\gamma\)</span> tales que <span
class="math inline">\(\alpha + \beta + \gamma = 1\)</span> y</p>
<p><span class="math display">\[
P = \alpha A + \beta B + \gamma C
\]</span></p>
<blockquote>
<p>TODO: triángulo con coordenadas baricéntricas.</p>
</blockquote>
<p>Debemos destacar que existen dos grados de libertad debido a la
restricción de que las coordenadas sumen 1.</p>
<p>Una propiedad de estas coordenadas que nos puede resultar útil es que
un punto <span class="math inline">\(P\)</span> está contenido en el
triángulo si y sólo si <span class="math inline">\(0 &lt; \alpha, \beta,
\gamma &lt; 1\)</span>.</p>
<p>Esta propiedad y la restricción de que sumen 1 nos da una cierta
intuición de cómo funcionan. Podemos ver las coordenadas baricéntricas
como la contribución de los vértices a un punto <span
class="math inline">\(P\)</span>. Por ejemplo, si <span
class="math inline">\(\alpha = 0\)</span>, eso significa que el punto
viene dado por <span class="math inline">\(\beta B + \gamma C\)</span>;
es decir, una combinación lineal de <span
class="math inline">\(B\)</span> y <span
class="math inline">\(C\)</span>. Se encuentra en la recta que
generan.</p>
<p>Por proponer otro ejemplo, si alguna de las coordenadas fuera mayor
que 1, eso significaría que el punto estaría más allá del triángulo.</p>
<blockquote>
<p>TODO: dibujo con explicación de cómo funciona (libreta Shinrin -
Yoku)</p>
</blockquote>
<h4 id="calculando-la-intersección">Calculando la intersección</h4>
<p>Podemos eliminar una de las varibales escribiendo <span
class="math inline">\(\alpha = 1 - \beta - \gamma\)</span>, lo que nos
dice</p>
<p><span class="math display">\[
\begin{aligned}
P &amp; = (1 - \beta - \gamma) A + \beta B + \gamma C \\
  &amp; = A + (B - A) \beta + (C - A) \gamma
\end{aligned}
\]</span></p>
<p>bajo la restricción</p>
<p><span id="eq:beta_gamma" class="eqnos"><span class="math display">\[
\begin{aligned}
\beta + \gamma &amp; &lt; 1 \\
0 &amp; &lt; \beta          \\
0 &amp; &lt; \gamma
\end{aligned}
\]</span><span class="eqnos-number">(1)</span></span> </p>
<p>Un rayo <span class="math inline">\(P(t) = O + tD\)</span> impactará
en un punto del triángulo si se cumple</p>
<p><span class="math display">\[
P(t) = O + tD = A + (B - A) \beta + (C - A) \gamma
\]</span></p>
<p>cumpliendo [<a href="#eq:beta_gamma">1</a>]. Podemos expandir la
ecuación anterior en sus coordenadas para obtener</p>
<p><span class="math display">\[
\begin{aligned}
O_x + tD_x &amp; = A_x + (B_x - A_x) \beta + (C_x - A_x) \gamma  \\
O_y + tD_y &amp; = A_y + (B_y - A_y) \beta + (C_y - A_y) \gamma  \\
O_z + tD_z &amp; = A_z + (B_z - A_z) \beta + (C_z - A_z) \gamma  \\
\end{aligned}
\]</span></p>
<p>Reordenamos:</p>
<p><span class="math display">\[
\begin{aligned}
(A_x - B_x) \beta + (A_x - C_x) \gamma+ tD_x &amp; = A_x - O_x   \\
(A_y - B_y) \beta + (A_y - C_y) \gamma+ tD_y &amp; = A_y - O_y   \\
(A_z - B_z) \beta + (A_z - C_z) \gamma+ tD_z &amp; = A_z - O_z
\end{aligned}
\]</span></p>
<p>Lo que nos permite escribir el sistema en forma de ecuación:</p>
<p><span class="math display">\[
\begin{pmatrix}
        A_x - B_x &amp; A_x - C_x &amp; D_x \\
        A_y - B_y &amp; A_y - C_y &amp; D_y \\
        A_z - B_z &amp; A_z - C_z &amp; D_z
\end{pmatrix}
\begin{pmatrix}
        \beta \\ \gamma \\ t
\end{pmatrix}
=
\begin{pmatrix}
        A_x - O_x \\ A_y - O_y \\ A_z - O_z
\end{pmatrix}
\]</span></p>
<p>Calcular rápidamente la solución a un sistema de ecuaciones lineales
es un problema habitual. En <span class="citation"
data-cites="ShirleyRRT">(<a href="#ref-ShirleyRRT"
role="doc-biblioref">Shirley and Morley 2003</a>)</span> se utiliza la
regla de Cramer para hacerlo, esperando que el compilador optimice las
variables intermedias creadas. Nosotros no nos tendremos que preocupar
de esto en particular, ya que el punto de impacto lo calculará la GPU
gracias a las <a
href="https://www.khronos.org/registry/vulkan/specs/1.2-khr-extensions/html/chap33.html#ray-intersection-candidate-determination">herramientras
aportadas por KHR</a>.</p>
<p>Para obtener el vector normal, podemos hacer el producto vectorial de
dos vectores que se encuentren en el plano del triángulo. Como, por
convención, los vértices se guardan en sentido antihorario visto desde
fuera del objeto, entonces</p>
<p><span class="math display">\[
\mathbf{n} = (B - A) \times (C - A)
\]</span></p>
<hr>
<p>Fuentes que he usado y que debería pasar:</p>
<ul>
<li>https://www.wikiwand.com/en/Implicit_surface</li>
<li>https://www.wikiwand.com/en/Parametric_surface</li>
<li>https://www.wikiwand.com/en/Barycentric_coordinate_system</li>
</ul>
<h1 id="integración-de-monte-carlo">Integración de Monte Carlo</h1>
<blockquote>
<p>TODO: este capítulo seguramente debería ir más tarde. De esa forma,
puedo introducir otros conceptos antes. De momento, se queda aquí.</p>
</blockquote>
<p>La parte más importante de nuestro ray tracer es saber calcular la
luz en un punto. Para ello, necesitaríamos hallar la radianza en dicho
punto mediante la <em>rendering equation</em>. Sin embargo, es
<em>muy</em> difícil resolverla. Tanto computacionalmente como
analíticamente. Por ello, debemos atacar el problema desde otro punto de
vista.</p>
<p>Las técnicas de Monte Carlo nos permitirán aproximar el valor que
toman mediante una estimación. Utilizando muestreo aleatorio para
evaluar integrales, seremos capaces de obtener un resultado
suficientemente bueno.</p>
<p>Una de las propiedades más improtantes que tienen es la
<strong>independencia del ratio de convergencia y la dimensionalidad del
integrando</strong>. Sin embargo, dadas <span
class="math inline">\(n\)</span> nuestras, la convergencia a la solución
correcta tiene un orden de <span
class="math inline">\(\mathcal{O}\left(n^{-1/2}\right)\)</span>. Es
decir, para reducir el error a la mitad, necesitaríamos 4 veces más
muestras.</p>
<h2 id="repaso-de-probabilidad">Repaso de probabilidad</h2>
<p>Necesitaremos unas cuantas nociones de variable aleatoria para poder
entender la integración de Monte Carlo, así que vamos a hacer un breve
repaso.</p>
<p>Una <strong>variable aleatoria</strong> <span
class="math inline">\(X\)</span> (v.a.) es, esencialmente, una regla que
asigna un valor numérico a cada posibilidad de algún proceso de azar.
Formalmente, una variable aleatoria es una función definida en un
espacio de probabilidad <span class="math inline">\((\Omega,
\mathcal{A}, P)\)</span> asociado a un exprimento aleatorio:</p>
<p><span class="math display">\[
X: \Omega \rightarrow \mathbb{R}
\]</span></p>
<p>A <span class="math inline">\(\Omega\)</span> lo conocemos como
espacio muestral (aquel conjunto de todas las posibilidades), <span
class="math inline">\(\mathcal{A}\)</span> es una <span
class="math inline">\(\sigma\)</span>-álgebra de subconjuntos de <span
class="math inline">\(\Omega\)</span> que refleja todas las
posibilidades de eventos aleatorios. <span
class="math inline">\(P\)</span> es una función probabilidad, que asigna
a cada evento una probabilidad.</p>
<blockquote>
<p>NOTE: no sé hasta qué punto debería meterme en la definición formal
de variable aleatoria. Es una movida tremenda para poca cosa que
necesitamos. De momento, voy con lo más interesante.</p>
</blockquote>
<p>Una variable aleatoria <span class="math inline">\(X\)</span> puede
clasificarse en discreta o continua, dependiendo de cómo sea su rango
<span class="math inline">\(R_X = \left\{ x \in \mathbb{R} \,\middle|\,
\exists \omega \in \Omega : X(\omega) = x \right\}\)</span>: discretas o
continuas.</p>
<h3 id="variables-aleatorias-discretas">Variables aleatorias
discretas</h3>
<p>Las v.a. discretas son aquellas cuyo rango es un conjunto
discreto.</p>
<p>Para comprender mejor cómo funcionan, pongamos un ejemplo.</p>
<p>Consideremos un experimento en el que lanzamos dos dados, anotando lo
que sale en cada uno. Los posibles valores que toman serán</p>
<p><span class="math display">\[
\begin{aligned}
\{ &amp; (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),  \\
   &amp; (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6),  \\
   &amp; (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6),  \\
   &amp; (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6),  \\
   &amp; (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6),  \\
   &amp; (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)   \}
\end{aligned}
\]</span></p>
<p>Cada resultado tiene la misma probabilidad de ocurrir (claro está, si
el dado no está trucado). Como hay <span
class="math inline">\(36\)</span> posibilidades, la probabilidad de
obtener un cierto valor es de <span
class="math inline">\(\frac{1}{36}\)</span>.</p>
<p>La v.a. <span class="math inline">\(X\)</span> denotará la suma de
los valores obtenidos en cada uno. Así, por ejemplo, si los dados han
dado <span class="math inline">\((1, 3)\)</span>, <span
class="math inline">\(X\)</span> será <span
class="math inline">\(4\)</span>. En total, <span
class="math inline">\(X\)</span> puede tomar todos los valores
comprendidos entre <span class="math inline">\(2\)</span> y <span
class="math inline">\(12\)</span>. Este sería el <strong>espacio
muestral</strong>. Además, podemos observar que <span
class="math inline">\(X\)</span> puede obtener el mismo valor para dos
resultados diferentes. Por ejemplo, <span class="math inline">\((1,
2)\)</span> suma lo mismo que <span class="math inline">\((2,
1)\)</span>. Esto nos lleva a preguntarnos… ¿cuál es la probabilidad de
que <span class="math inline">\(X\)</span> adquiera un cierto valor?</p>
<p>La <strong>función masa de probabilidad</strong> nos permite conocer
la probabilidad de que una variable aleatoria <span
class="math inline">\(X\)</span> tome un valor <span
class="math inline">\(x\)</span>. Se denota por <span
class="math inline">\(P(X = x)\)</span>.</p>
<p>En este ejemplo, la probabilidad de que <span
class="math inline">\(X\)</span> tome el valor <span
class="math inline">\(4\)</span> es</p>
<p><span class="math display">\[
P(X = 4) = p_i \cdot \text{nº parejas que sumen 4} = \frac{1}{36} \cdot
3 = \frac{1}{12}
\]</span></p>
<p>(Las parejas serían <span class="math inline">\((1, 3), (2, 2), (3,
1)\)</span>).</p>
<p>Por definición, si el espacio muestral de <span
class="math inline">\(X\)</span> es <span class="math inline">\(x_1,
\dots, x_n\)</span>, la función masa de probabilidad debe cumplir
que</p>
<p><span class="math display">\[
\sum_{i = 1}^{k}{P(X = x_i)} = 1
\]</span></p>
<p>La <strong>función de distribución</strong> de una variable aleatoria
<span class="math inline">\(X\)</span> es</p>
<p><span class="math display">\[
F_X(x) = P(X \le x) = \sum_{k = -\infty}^{x}{P(X = x)} = 1
\]</span></p>
<p>Es una función continua por la derecha y monótona no decreciente.
Además, se cumple que <span class="math inline">\(\lim_{x \to
-\infty}{F_X} = 0\)</span>, <span class="math inline">\(\lim_{x \to
\infty}{F_X} = 1\)</span></p>
<h3 id="variables-aleatorias-continuas">Variables aleatorias
continuas</h3>
<p>Estas variables aleatorias tienen un rango no numerable.</p>
<hr>
<ul>
<li>https://www.wikiwand.com/en/Rendering_equation</li>
<li>https://www.wikiwand.com/es/Variable_aleatoria</li>
<li>https://www.wikiwand.com/es/Distribuci%C3%B3n_de_probabilidad#/Distribuciones_de_variable_discreta</li>
<li>https://www.wikiwand.com/es/Funci%C3%B3n_de_probabilidad</li>
<li>https://www.pbr-book.org/3ed-2018/contents</li>
<li>https://www3.nd.edu/~dgalvin1/10120/10120_S16/Topic17_8p4_Galvin_class.pdf</li>
<li>RTT Shirley.</li>
</ul>
<h1 id="metodología-o-cómo-se-hizo-este-trabajo">Metodología; o cómo se
hizo este trabajo</h1>
<blockquote>
<p>TODO - hablar de las fases de desarrollo. Interpretación propia de
Agile. Documentación y código desarrollado a la par, mediante issues.
Adaptación de los requisitos conforme se avanza. Beneficios de una
página web (seguramente debería ser su propia sección)</p>
</blockquote>
<h2 id="github">Github</h2>
<blockquote>
<p>TODO - Hablar de cómo se utiliza Github y sus tecnologías para
agrupar todo el trabajo. Hablar de la guía de estilos, y cómo los emojis
ayudan a identificar rápidamente secciones.</p>
</blockquote>
<h3 id="github-actions">Github Actions</h3>
<blockquote>
<p>TODO - Hablar de cómo se usa el sistema de integración continua para
construir la web y el pdf</p>
</blockquote>
<h3 id="github-projects">Github Projects</h3>
<blockquote>
<p>TODO - Hablar de cómo se gestiona el trabajo mediante issues,
recapitulados todos con Projects.</p>
</blockquote>
<h1 class="unnumbered" id="anexo-cheatsheet">Anexo: Cheatsheet</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-ShirleyRRT" class="csl-entry" role="doc-biblioentry">
Shirley, Peter, and R. Keith Morley. 2003. <em>Realistic Ray
Tracing</em>. 2nd ed. USA: A. K. Peters, Ltd.
</div>
</div>
</body>
</html>
